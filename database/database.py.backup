"""
Enhanced Database connection manager with improved schema for signal lifecycle tracking
"""
import aiosqlite
import asyncio
from pathlib import Path
from typing import Optional, List, Dict, Any
from contextlib import asynccontextmanager
from datetime import datetime
import pytz
from utils.logger import get_logger

logger = get_logger("database")


class DatabaseManager:
    """Manages database connections and base operations with enhanced signal tracking"""

    # Signal status constants
    STATUS_ACTIVE = 'active'
    STATUS_HIT = 'hit'
    STATUS_PROFIT = 'profit'
    STATUS_BREAKEVEN = 'breakeven'
    STATUS_STOP_LOSS = 'stop_loss'
    STATUS_CANCELLED = 'cancelled'

    # Final statuses for analytics
    FINAL_STATUSES = [STATUS_PROFIT, STATUS_BREAKEVEN, STATUS_STOP_LOSS, STATUS_CANCELLED]

    # Limit status constants
    LIMIT_STATUS_PENDING = 'pending'
    LIMIT_STATUS_HIT = 'hit'
    LIMIT_STATUS_CANCELLED = 'cancelled'

    def __init__(self, db_path: str = "data/trading_bot.db"):
        """
        Initialize database manager

        Args:
            db_path: Path to SQLite database file
        """
        self.db_path = db_path
        self._connection: Optional[aiosqlite.Connection] = None
        self._lock = asyncio.Lock()

        # Ensure data directory exists
        Path(db_path).parent.mkdir(parents=True, exist_ok=True)

    async def initialize(self):
        """Initialize database and create enhanced tables"""
        async with self.get_connection() as conn:
            # Enable foreign key constraints
            await conn.execute("PRAGMA foreign_keys = ON")

            # Create enhanced signals table
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS signals (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    message_id TEXT UNIQUE NOT NULL,
                    channel_id TEXT NOT NULL,
                    instrument TEXT NOT NULL,
                    direction TEXT NOT NULL,
                    stop_loss REAL NOT NULL,
                    expiry_type TEXT,
                    expiry_time TIMESTAMP,
                    status TEXT DEFAULT 'active',
                    
                    -- New fields for enhanced tracking
                    first_limit_hit_time TIMESTAMP,     -- When first limit was hit
                    closed_at TIMESTAMP,                 -- When signal reached final status
                    closed_reason TEXT,                  -- 'automatic' or 'manual'
                    result_pips REAL,                    -- For future P&L tracking
                    
                    -- Tracking fields
                    total_limits INTEGER DEFAULT 0,      -- Total number of limits
                    limits_hit INTEGER DEFAULT 0,        -- Number of limits hit
                    
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    
                    -- Constraints
                    CHECK (status IN ('active', 'hit', 'profit', 'breakeven', 'stop_loss', 'cancelled')),
                    CHECK (direction IN ('long', 'short'))
                )
            """)

            # Create enhanced limits table
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS limits (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    signal_id INTEGER NOT NULL,
                    price_level REAL NOT NULL,
                    sequence_number INTEGER NOT NULL,    -- Order of limits (1st, 2nd, 3rd)
                    
                    -- Status tracking
                    status TEXT DEFAULT 'pending',
                    hit_time TIMESTAMP,
                    hit_price REAL,                      -- Actual price when hit (for spread tracking)
                    
                    -- Alert tracking
                    approaching_alert_sent BOOLEAN DEFAULT FALSE,
                    hit_alert_sent BOOLEAN DEFAULT FALSE,
                    
                    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    
                    FOREIGN KEY (signal_id) REFERENCES signals(id) ON DELETE CASCADE,
                    CHECK (status IN ('pending', 'hit', 'cancelled')),
                    UNIQUE(signal_id, sequence_number)
                )
            """)

            # Create status_changes table for audit trail (optional but useful)
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS status_changes (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    signal_id INTEGER NOT NULL,
                    old_status TEXT,
                    new_status TEXT NOT NULL,
                    change_type TEXT NOT NULL,           -- 'automatic' or 'manual'
                    reason TEXT,                          -- Optional reason for manual changes
                    changed_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                    
                    FOREIGN KEY (signal_id) REFERENCES signals(id) ON DELETE CASCADE
                )
            """)

            # Create performance metrics table for analytics
            await conn.execute("""
                CREATE TABLE IF NOT EXISTS performance_metrics (
                    id INTEGER PRIMARY KEY AUTOINCREMENT,
                    date DATE NOT NULL,
                    instrument TEXT,
                    total_signals INTEGER DEFAULT 0,
                    profitable INTEGER DEFAULT 0,
                    breakeven INTEGER DEFAULT 0,
                    stop_loss INTEGER DEFAULT 0,
                    cancelled INTEGER DEFAULT 0,
                    win_rate REAL,
                    
                    UNIQUE(date, instrument)
                )
            """)

            # Create comprehensive indexes
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_status ON signals(status)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_channel ON signals(channel_id)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_message ON signals(message_id)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_instrument ON signals(instrument)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_signals_closed_at ON signals(closed_at)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_limits_signal ON limits(signal_id)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_limits_status ON limits(status)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_status_changes_signal ON status_changes(signal_id)")
            await conn.execute("CREATE INDEX IF NOT EXISTS idx_performance_date ON performance_metrics(date)")

            await conn.commit()
            logger.info("Enhanced database initialized successfully")

    @asynccontextmanager
    async def get_connection(self):
        """
        Get database connection with context manager

        Yields:
            Database connection
        """
        async with self._lock:
            conn = await aiosqlite.connect(self.db_path)
            conn.row_factory = aiosqlite.Row  # Return rows as dictionaries
            await conn.execute("PRAGMA foreign_keys = ON")  # Ensure foreign keys are enabled
            try:
                yield conn
            finally:
                await conn.close()

    async def execute(self, query: str, params: tuple = ()) -> int:
        """
        Execute a query that modifies data

        Args:
            query: SQL query
            params: Query parameters

        Returns:
            Last row ID for inserts, or number of affected rows
        """
        async with self.get_connection() as conn:
            cursor = await conn.execute(query, params)
            await conn.commit()
            return cursor.lastrowid if cursor.lastrowid else cursor.rowcount

    async def execute_many(self, query: str, params_list: List[tuple]) -> int:
        """
        Execute multiple queries with different parameters

        Args:
            query: SQL query
            params_list: List of parameter tuples

        Returns:
            Number of affected rows
        """
        async with self.get_connection() as conn:
            await conn.executemany(query, params_list)
            await conn.commit()
            return len(params_list)

    async def fetch_one(self, query: str, params: tuple = ()) -> Optional[Dict[str, Any]]:
        """
        Fetch a single row

        Args:
            query: SQL query
            params: Query parameters

        Returns:
            Row as dictionary or None
        """
        async with self.get_connection() as conn:
            cursor = await conn.execute(query, params)
            row = await cursor.fetchone()
            return dict(row) if row else None

    async def fetch_all(self, query: str, params: tuple = ()) -> List[Dict[str, Any]]:
        """
        Fetch all rows

        Args:
            query: SQL query
            params: Query parameters

        Returns:
            List of rows as dictionaries
        """
        async with self.get_connection() as conn:
            cursor = await conn.execute(query, params)
            rows = await cursor.fetchall()
            return [dict(row) for row in rows]

    async def insert_signal(self, message_id: str, channel_id: str, instrument: str,
                           direction: str, stop_loss: float, expiry_type: str = None,
                           expiry_time: str = None, total_limits: int = 0) -> int:
        """
        Insert a new signal with enhanced tracking

        Args:
            message_id: Discord message ID
            channel_id: Discord channel ID
            instrument: Trading instrument (e.g., GBPUSD)
            direction: Trade direction (long/short)
            stop_loss: Stop loss price
            expiry_type: Expiry type (day_end, week_end, etc.)
            expiry_time: Calculated expiry timestamp
            total_limits: Total number of limit orders

        Returns:
            Signal ID
        """
        query = """
            INSERT INTO signals (
                message_id, channel_id, instrument, direction, 
                stop_loss, expiry_type, expiry_time, total_limits, status
            )
            VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)
        """

        signal_id = await self.execute(
            query,
            (message_id, channel_id, instrument, direction, stop_loss,
             expiry_type, expiry_time, total_limits, self.STATUS_ACTIVE)
        )

        logger.info(f"Inserted signal {signal_id} for {instrument} {direction} with {total_limits} limits")
        return signal_id

    async def insert_limits(self, signal_id: int, price_levels: List[float]):
        """
        Insert limits for a signal with sequence numbers

        Args:
            signal_id: Parent signal ID
            price_levels: List of limit prices (ordered)
        """
        query = """
            INSERT INTO limits (signal_id, price_level, sequence_number, status) 
            VALUES (?, ?, ?, ?)
        """

        params_list = [
            (signal_id, level, idx + 1, self.LIMIT_STATUS_PENDING)
            for idx, level in enumerate(price_levels)
        ]

        await self.execute_many(query, params_list)
        logger.info(f"Inserted {len(price_levels)} limits for signal {signal_id}")

    async def update_signal_status(self, signal_id: int, new_status: str,
                                  change_type: str = 'automatic', reason: str = None) -> bool:
        """
        Update signal status with proper lifecycle management

        Args:
            signal_id: Signal ID
            new_status: New status
            change_type: 'automatic' or 'manual'
            reason: Optional reason for change

        Returns:
            Success status
        """
        async with self.get_connection() as conn:
            # Get current status
            current = await self.fetch_one(
                "SELECT status FROM signals WHERE id = ?",
                (signal_id,)
            )

            if not current:
                logger.error(f"Signal {signal_id} not found")
                return False

            old_status = current['status']

            # Validate status transition
            if not self._is_valid_transition(old_status, new_status):
                logger.warning(f"Invalid status transition: {old_status} -> {new_status}")
                return False

            # Update signal
            now = datetime.now(pytz.UTC).isoformat()

            if new_status in self.FINAL_STATUSES:
                # Set closed_at for final statuses
                query = """
                    UPDATE signals 
                    SET status = ?, updated_at = ?, closed_at = ?, closed_reason = ?
                    WHERE id = ?
                """
                await conn.execute(query, (new_status, now, now, change_type, signal_id))
            else:
                # Regular status update
                query = """
                    UPDATE signals 
                    SET status = ?, updated_at = ?
                    WHERE id = ?
                """
                await conn.execute(query, (new_status, now, signal_id))

            # Record status change
            await conn.execute("""
                INSERT INTO status_changes (signal_id, old_status, new_status, change_type, reason)
                VALUES (?, ?, ?, ?, ?)
            """, (signal_id, old_status, new_status, change_type, reason))

            await conn.commit()

            logger.info(f"Updated signal {signal_id}: {old_status} -> {new_status} ({change_type})")
            return True

    async def mark_limit_hit(self, limit_id: int, hit_price: float = None) -> Dict[str, Any]:
        """
        Mark a limit as hit and update signal status if needed

        Args:
            limit_id: Limit ID
            hit_price: Actual price when hit (for spread tracking)

        Returns:
            Dict with signal_id and whether signal status changed
        """
        async with self.get_connection() as conn:
            # Get limit and signal info
            query = """
                SELECT l.*, s.status as signal_status, s.id as signal_id
                FROM limits l
                JOIN signals s ON l.signal_id = s.id
                WHERE l.id = ?
            """
            result = await conn.execute(query, (limit_id,))
            limit_data = await result.fetchone()

            if not limit_data:
                logger.error(f"Limit {limit_id} not found")
                return {'signal_id': None, 'status_changed': False}

            limit_data = dict(limit_data)
            signal_id = limit_data['signal_id']

            # Update limit
            now = datetime.now(pytz.UTC).isoformat()
            await conn.execute("""
                UPDATE limits 
                SET status = ?, hit_time = ?, hit_price = ?
                WHERE id = ?
            """, (self.LIMIT_STATUS_HIT, now, hit_price or limit_data['price_level'], limit_id))

            # Update signal limits_hit count
            await conn.execute("""
                UPDATE signals 
                SET limits_hit = limits_hit + 1,
                    updated_at = ?
                WHERE id = ?
            """, (now, signal_id))

            # Check if signal status should change from active to hit
            status_changed = False
            if limit_data['signal_status'] == self.STATUS_ACTIVE:
                await conn.execute("""
                    UPDATE signals 
                    SET status = ?, first_limit_hit_time = ?, updated_at = ?
                    WHERE id = ?
                """, (self.STATUS_HIT, now, now, signal_id))

                # Record status change
                await conn.execute("""
                    INSERT INTO status_changes (signal_id, old_status, new_status, change_type, reason)
                    VALUES (?, ?, ?, ?, ?)
                """, (signal_id, self.STATUS_ACTIVE, self.STATUS_HIT, 'automatic', f'Limit {limit_id} hit'))

                status_changed = True
                logger.info(f"Signal {signal_id} status changed to HIT (first limit hit)")

            await conn.commit()

            return {
                'signal_id': signal_id,
                'status_changed': status_changed,
                'signal_status': self.STATUS_HIT if status_changed else limit_data['signal_status']
            }

    async def check_stop_loss_hit(self, signal_id: int, current_price: float) -> bool:
        """
        Check if stop loss has been hit and update status if needed

        Args:
            signal_id: Signal ID
            current_price: Current market price

        Returns:
            True if stop loss was hit
        """
        signal = await self.fetch_one("""
            SELECT direction, stop_loss, status 
            FROM signals 
            WHERE id = ?
        """, (signal_id,))

        if not signal or signal['status'] not in [self.STATUS_HIT]:
            return False

        stop_hit = False

        if signal['direction'] == 'long' and current_price <= signal['stop_loss']:
            stop_hit = True
        elif signal['direction'] == 'short' and current_price >= signal['stop_loss']:
            stop_hit = True

        if stop_hit:
            await self.update_signal_status(
                signal_id,
                self.STATUS_STOP_LOSS,
                'automatic',
                f'Stop loss hit at {current_price}'
            )
            logger.info(f"Signal {signal_id} hit stop loss at {current_price}")

        return stop_hit

    async def get_active_signals_for_tracking(self) -> List[Dict[str, Any]]:
        """
        Get all signals that need price tracking (ACTIVE or HIT status)

        Returns:
            List of signals with their pending limits
        """
        query = """
            SELECT 
                s.id as signal_id,
                s.instrument,
                s.direction,
                s.stop_loss,
                s.status,
                s.limits_hit,
                s.total_limits,
                l.id as limit_id,
                l.price_level,
                l.sequence_number,
                l.approaching_alert_sent,
                l.hit_alert_sent
            FROM signals s
            LEFT JOIN limits l ON s.id = l.signal_id AND l.status = ?
            WHERE s.status IN (?, ?)
            ORDER BY s.id, l.sequence_number
        """

        rows = await self.fetch_all(
            query,
            (self.LIMIT_STATUS_PENDING, self.STATUS_ACTIVE, self.STATUS_HIT)
        )

        # Group by signal
        signals = {}
        for row in rows:
            signal_id = row['signal_id']
            if signal_id not in signals:
                signals[signal_id] = {
                    'signal_id': signal_id,
                    'instrument': row['instrument'],
                    'direction': row['direction'],
                    'stop_loss': row['stop_loss'],
                    'status': row['status'],
                    'limits_hit': row['limits_hit'],
                    'total_limits': row['total_limits'],
                    'pending_limits': []
                }

            # Add pending limit if exists
            if row['limit_id']:
                signals[signal_id]['pending_limits'].append({
                    'limit_id': row['limit_id'],
                    'price_level': row['price_level'],
                    'sequence_number': row['sequence_number'],
                    'approaching_alert_sent': row['approaching_alert_sent'],
                    'hit_alert_sent': row['hit_alert_sent']
                })

        return list(signals.values())

    async def mark_approaching_alert_sent(self, limit_id: int) -> bool:
        """
        Mark that an approaching alert has been sent for a limit

        Args:
            limit_id: Limit ID

        Returns:
            Success status
        """
        query = "UPDATE limits SET approaching_alert_sent = TRUE WHERE id = ?"
        rows = await self.execute(query, (limit_id,))
        return rows > 0

    async def mark_hit_alert_sent(self, limit_id: int) -> bool:
        """
        Mark that a hit alert has been sent for a limit

        Args:
            limit_id: Limit ID

        Returns:
            Success status
        """
        query = "UPDATE limits SET hit_alert_sent = TRUE WHERE id = ?"
        rows = await self.execute(query, (limit_id,))
        return rows > 0

    async def get_performance_stats(self, start_date: str = None, end_date: str = None,
                                   instrument: str = None) -> Dict[str, Any]:
        """
        Get performance statistics for closed signals

        Args:
            start_date: Start date (ISO format)
            end_date: End date (ISO format)
            instrument: Optional instrument filter

        Returns:
            Performance statistics
        """
        # Build query
        conditions = ["status IN ('profit', 'breakeven', 'stop_loss')"]
        params = []

        if start_date:
            conditions.append("closed_at >= ?")
            params.append(start_date)

        if end_date:
            conditions.append("closed_at <= ?")
            params.append(end_date)

        if instrument:
            conditions.append("instrument = ?")
            params.append(instrument)

        where_clause = " AND ".join(conditions) if conditions else "1=1"

        query = f"""
            SELECT 
                COUNT(*) as total_trades,
                COUNT(CASE WHEN status = 'profit' THEN 1 END) as profitable,
                COUNT(CASE WHEN status = 'breakeven' THEN 1 END) as breakeven,
                COUNT(CASE WHEN status = 'stop_loss' THEN 1 END) as stop_loss,
                ROUND(
                    CAST(COUNT(CASE WHEN status = 'profit' THEN 1 END) AS FLOAT) / 
                    NULLIF(COUNT(*), 0) * 100, 2
                ) as win_rate
            FROM signals
            WHERE {where_clause}
        """

        stats = await self.fetch_one(query, tuple(params))

        # Get breakdown by instrument
        instrument_query = f"""
            SELECT 
                instrument,
                COUNT(*) as total,
                COUNT(CASE WHEN status = 'profit' THEN 1 END) as wins
            FROM signals
            WHERE {where_clause}
            GROUP BY instrument
        """

        instrument_stats = await self.fetch_all(instrument_query, tuple(params))

        return {
            'overall': dict(stats) if stats else {},
            'by_instrument': instrument_stats
        }

    def _is_valid_transition(self, old_status: str, new_status: str) -> bool:
        """
        Check if a status transition is valid

        Args:
            old_status: Current status
            new_status: Desired new status

        Returns:
            Whether transition is valid
        """
        # Define valid transitions
        valid_transitions = {
            self.STATUS_ACTIVE: [self.STATUS_HIT, self.STATUS_CANCELLED, self.STATUS_STOP_LOSS],
            self.STATUS_HIT: [self.STATUS_PROFIT, self.STATUS_BREAKEVEN,
                             self.STATUS_STOP_LOSS, self.STATUS_CANCELLED],
            self.STATUS_CANCELLED: [self.STATUS_HIT, self.STATUS_ACTIVE],  # Can revert cancellation
            # Final statuses generally can't transition, but allow cancel from profit/breakeven for corrections
            self.STATUS_PROFIT: [self.STATUS_CANCELLED],
            self.STATUS_BREAKEVEN: [self.STATUS_CANCELLED],
            self.STATUS_STOP_LOSS: [self.STATUS_CANCELLED]
        }

        return new_status in valid_transitions.get(old_status, [])

    async def close(self):
        """Close database connection"""
        if self._connection:
            await self._connection.close()
            self._connection = None


# Global database instance
db = DatabaseManager()