"""
Enhanced Signal-specific database operations with full lifecycle tracking
"""
from typing import Optional, List, Dict, Any, Tuple
from datetime import datetime, timedelta
from enum import Enum
import pytz
from database.database import DatabaseManager
from core.parser import ParsedSignal
from utils.logger import get_logger

logger = get_logger("signal_db")


class SignalStatus(Enum):
    """Signal status enumeration"""
    ACTIVE = 'active'
    HIT = 'hit'
    PROFIT = 'profit'
    BREAKEVEN = 'breakeven'
    STOP_LOSS = 'stop_loss'
    CANCELLED = 'cancelled'

    @classmethod
    def is_final(cls, status: str) -> bool:
        """Check if status is final"""
        return status in [cls.PROFIT.value, cls.BREAKEVEN.value,
                         cls.STOP_LOSS.value, cls.CANCELLED.value]

    @classmethod
    def is_trackable(cls, status: str) -> bool:
        """Check if status requires price tracking"""
        return status in [cls.ACTIVE.value, cls.HIT.value]


class SignalDatabase:
    """Handles signal-specific database operations with enhanced lifecycle management"""

    def __init__(self, db_manager: DatabaseManager):
        """
        Initialize signal database handler

        Args:
            db_manager: Database manager instance
        """
        self.db = db_manager

    async def save_signal(self, parsed_signal: ParsedSignal, message_id: str,
                         channel_id: str) -> Tuple[bool, Optional[int]]:
        """
        Save a parsed signal to the database

        Args:
            parsed_signal: Parsed signal object
            message_id: Discord message ID
            channel_id: Discord channel ID

        Returns:
            Tuple of (success, signal_id)
        """
        try:
            # Check if signal already exists
            existing = await self.get_signal_by_message_id(message_id)
            if existing:
                # Check if it was cancelled and can be reactivated
                if existing['status'] == SignalStatus.CANCELLED.value:
                    logger.info(f"Reactivating cancelled signal for message {message_id}")
                    await self.reactivate_cancelled_signal(existing['id'], parsed_signal)
                    return True, existing['id']
                else:
                    logger.warning(f"Signal already exists for message {message_id}")
                    return False, existing['id']

            # Calculate expiry time
            expiry_time = self._calculate_expiry(parsed_signal.expiry_type)

            # Insert signal with total limits count
            signal_id = await self.db.insert_signal(
                message_id=message_id,
                channel_id=channel_id,
                instrument=parsed_signal.instrument,
                direction=parsed_signal.direction,
                stop_loss=parsed_signal.stop_loss,
                expiry_type=parsed_signal.expiry_type,
                expiry_time=expiry_time,
                total_limits=len(parsed_signal.limits) if parsed_signal.limits else 0
            )

            # Insert limits with sequence numbers
            if signal_id and parsed_signal.limits:
                await self.db.insert_limits(signal_id, parsed_signal.limits)

            logger.info(f"Saved signal {signal_id}: {parsed_signal.instrument} "
                       f"{parsed_signal.direction} with {len(parsed_signal.limits)} limits")
            return True, signal_id

        except Exception as e:
            logger.error(f"Error saving signal: {e}", exc_info=True)
            return False, None

    async def get_signal_by_message_id(self, message_id: str) -> Optional[Dict[str, Any]]:
        """
        Get signal by Discord message ID

        Args:
            message_id: Discord message ID

        Returns:
            Signal data or None
        """
        query = "SELECT * FROM signals WHERE message_id = ?"
        return await self.db.fetch_one(query, (message_id,))

    async def get_signal_with_limits(self, signal_id: int) -> Optional[Dict[str, Any]]:
        """
        Get signal with all its limits (including hit ones)

        Args:
            signal_id: Signal ID

        Returns:
            Signal data with limits
        """
        # Get signal
        signal_query = "SELECT * FROM signals WHERE id = ?"
        signal = await self.db.fetch_one(signal_query, (signal_id,))

        if not signal:
            return None

        # Get all limits (pending and hit)
        limits_query = """
            SELECT * FROM limits 
            WHERE signal_id = ? 
            ORDER BY sequence_number
        """
        limits = await self.db.fetch_all(limits_query, (signal_id,))

        signal['limits'] = limits
        signal['pending_limits'] = [l for l in limits if l['status'] == 'pending']
        signal['hit_limits'] = [l for l in limits if l['status'] == 'hit']

        return signal

    async def update_signal_from_edit(self, message_id: str, parsed_signal: ParsedSignal) -> bool:
        """
        Update an existing signal from an edited message

        Args:
            message_id: Discord message ID
            parsed_signal: Newly parsed signal

        Returns:
            Success status
        """
        try:
            # Get existing signal
            existing = await self.get_signal_by_message_id(message_id)
            if not existing:
                logger.warning(f"No signal found for message {message_id}")
                return False

            signal_id = existing['id']

            # Only allow updates if signal is not in final status
            if SignalStatus.is_final(existing['status']):
                logger.warning(f"Cannot update signal {signal_id} in final status {existing['status']}")
                return False

            # Update signal basic info
            update_query = """
                UPDATE signals 
                SET instrument = ?, direction = ?, stop_loss = ?, 
                    expiry_type = ?, total_limits = ?, updated_at = CURRENT_TIMESTAMP
                WHERE id = ?
            """
            await self.db.execute(
                update_query,
                (parsed_signal.instrument, parsed_signal.direction,
                 parsed_signal.stop_loss, parsed_signal.expiry_type,
                 len(parsed_signal.limits), signal_id)
            )

            # Get existing limits that were hit
            hit_limits_query = """
                SELECT price_level FROM limits 
                WHERE signal_id = ? AND status = 'hit'
                ORDER BY sequence_number
            """
            hit_limits = await self.db.fetch_all(hit_limits_query, (signal_id,))
            hit_prices = [l['price_level'] for l in hit_limits]

            # Delete old limits
            delete_limits = "DELETE FROM limits WHERE signal_id = ?"
            await self.db.execute(delete_limits, (signal_id,))

            # Insert new limits, preserving hit status for matching prices
            for idx, level in enumerate(parsed_signal.limits):
                if level in hit_prices:
                    # Re-insert as hit
                    await self.db.execute("""
                        INSERT INTO limits (signal_id, price_level, sequence_number, status, hit_time)
                        VALUES (?, ?, ?, 'hit', CURRENT_TIMESTAMP)
                    """, (signal_id, level, idx + 1))
                else:
                    # Insert as pending
                    await self.db.execute("""
                        INSERT INTO limits (signal_id, price_level, sequence_number, status)
                        VALUES (?, ?, ?, 'pending')
                    """, (signal_id, level, idx + 1))

            logger.info(f"Updated signal {signal_id} from edited message")
            return True

        except Exception as e:
            logger.error(f"Error updating signal from edit: {e}", exc_info=True)
            return False

    async def cancel_signal_by_message(self, message_id: str) -> bool:
        """
        Cancel a signal when its message is deleted or cancelled by user

        Args:
            message_id: Discord message ID

        Returns:
            Success status
        """
        try:
            logger.debug(f"Starting cancel_signal_by_message for message {message_id}")

            # Get signal
            signal = await self.get_signal_by_message_id(message_id)
            if not signal:
                logger.warning(f"No signal found for message {message_id}")
                return False

            logger.debug(f"Found signal {signal['id']} with status {signal['status']}")

            # Check if already cancelled
            if signal['status'] == SignalStatus.CANCELLED.value:
                logger.info(f"Signal {signal['id']} is already cancelled")
                return True

            # Check if in final status that can't be cancelled
            if SignalStatus.is_final(signal['status']) and signal['status'] != SignalStatus.CANCELLED.value:
                logger.warning(f"Cannot cancel signal {signal['id']} in final status {signal['status']}")
                return False

            # Directly update the signal status without validation
            # (since we're cancelling, we bypass normal transition rules)
            try:
                async with self.db.get_connection() as conn:
                    now = datetime.now(pytz.UTC).isoformat()

                    # Update signal status
                    await conn.execute("""
                        UPDATE signals 
                        SET status = ?, updated_at = ?, closed_at = ?, closed_reason = ?
                        WHERE id = ?
                    """, (SignalStatus.CANCELLED.value, now, now, 'manual', signal['id']))

                    # Record status change
                    await conn.execute("""
                        INSERT INTO status_changes (signal_id, old_status, new_status, change_type, reason)
                        VALUES (?, ?, ?, ?, ?)
                    """, (signal['id'], signal['status'], SignalStatus.CANCELLED.value, 'manual', 'User cancelled'))

                    # Cancel all pending limits
                    await conn.execute("""
                        UPDATE limits 
                        SET status = 'cancelled' 
                        WHERE signal_id = ? AND status = 'pending'
                    """, (signal['id'],))

                    await conn.commit()

                logger.info(f"Successfully cancelled signal {signal['id']}")
                return True

            except Exception as e:
                logger.error(f"Database error while cancelling signal: {e}", exc_info=True)
                return False

        except Exception as e:
            logger.error(f"Error in cancel_signal_by_message: {e}", exc_info=True)
            return False

    async def reactivate_cancelled_signal(self, signal_id: int, parsed_signal: ParsedSignal) -> bool:
        """
        Reactivate a cancelled signal (e.g., when message is undeleted or edited)

        Args:
            signal_id: Signal ID to reactivate
            parsed_signal: New parsed signal data

        Returns:
            Success status
        """
        try:
            logger.debug(f"Attempting to reactivate signal {signal_id}")

            # Get current signal state
            signal = await self.get_signal_with_limits(signal_id)
            if not signal:
                logger.error(f"Signal {signal_id} not found")
                return False

            if signal['status'] != SignalStatus.CANCELLED.value:
                logger.warning(f"Signal {signal_id} is not cancelled, status: {signal['status']}")
                return False

            # Determine new status based on whether any limits were hit before cancellation
            new_status = SignalStatus.HIT.value if signal.get('limits_hit', 0) > 0 else SignalStatus.ACTIVE.value

            # Directly update without going through validation
            try:
                async with self.db.get_connection() as conn:
                    now = datetime.now(pytz.UTC).isoformat()

                    # Clear closed_at and update status
                    await conn.execute("""
                        UPDATE signals 
                        SET status = ?, closed_at = NULL, closed_reason = NULL, updated_at = ?
                        WHERE id = ?
                    """, (new_status, now, signal_id))

                    # Record status change
                    await conn.execute("""
                        INSERT INTO status_changes (signal_id, old_status, new_status, change_type, reason)
                        VALUES (?, ?, ?, ?, ?)
                    """, (signal_id, SignalStatus.CANCELLED.value, new_status, 'manual', 'Signal reactivated'))

                    # Reactivate cancelled limits as pending
                    await conn.execute("""
                        UPDATE limits 
                        SET status = 'pending' 
                        WHERE signal_id = ? AND status = 'cancelled'
                    """, (signal_id,))

                    await conn.commit()

                logger.info(f"Successfully reactivated signal {signal_id} to status {new_status}")
                return True

            except Exception as e:
                logger.error(f"Database error reactivating signal: {e}", exc_info=True)
                return False

        except Exception as e:
            logger.error(f"Error reactivating signal: {e}", exc_info=True)
            return False

    async def manually_set_signal_status(self, signal_id: int, new_status: str,
                                        reason: str = None) -> bool:
        """
        Manually set a signal's status (for admin override)
        Bypasses validation for manual overrides

        Args:
            signal_id: Signal ID
            new_status: New status to set
            reason: Optional reason for manual change

        Returns:
            Success status
        """
        try:
            logger.debug(f"Manually setting signal {signal_id} to {new_status}")

            # Validate status
            if new_status not in [s.value for s in SignalStatus]:
                logger.error(f"Invalid status: {new_status}")
                return False

            # Get current signal
            signal = await self.db.fetch_one(
                "SELECT * FROM signals WHERE id = ?",
                (signal_id,)
            )

            if not signal:
                logger.error(f"Signal {signal_id} not found")
                return False

            old_status = signal['status']

            # If same status, return success
            if old_status == new_status:
                logger.info(f"Signal {signal_id} already has status {new_status}")
                return True

            # For manual overrides, bypass validation and directly update
            try:
                async with self.db.get_connection() as conn:
                    now = datetime.now(pytz.UTC).isoformat()

                    # Update based on whether it's a final status
                    if SignalStatus.is_final(new_status):
                        await conn.execute("""
                            UPDATE signals 
                            SET status = ?, updated_at = ?, closed_at = ?, closed_reason = ?
                            WHERE id = ?
                        """, (new_status, now, now, 'manual', signal_id))
                    else:
                        # If reverting from final to non-final, clear closed_at
                        await conn.execute("""
                            UPDATE signals 
                            SET status = ?, updated_at = ?, closed_at = NULL, closed_reason = NULL
                            WHERE id = ?
                        """, (new_status, now, signal_id))

                    # Record status change
                    await conn.execute("""
                        INSERT INTO status_changes (signal_id, old_status, new_status, change_type, reason)
                        VALUES (?, ?, ?, ?, ?)
                    """, (signal_id, old_status, new_status, 'manual', reason or 'Manual override'))

                    # Handle limits based on new status
                    if SignalStatus.is_final(new_status):
                        # Cancel any pending limits
                        await conn.execute("""
                            UPDATE limits 
                            SET status = 'cancelled' 
                            WHERE signal_id = ? AND status = 'pending'
                        """, (signal_id,))
                    elif new_status == SignalStatus.ACTIVE.value:
                        # If reverting to active, reactivate cancelled limits
                        await conn.execute("""
                            UPDATE limits 
                            SET status = 'pending' 
                            WHERE signal_id = ? AND status = 'cancelled'
                        """, (signal_id,))

                    await conn.commit()

                logger.info(f"Successfully set signal {signal_id} status: {old_status} -> {new_status}")
                return True

            except Exception as e:
                logger.error(f"Database error setting status: {e}", exc_info=True)
                return False

        except Exception as e:
            logger.error(f"Error manually setting signal status: {e}", exc_info=True)
            return False

    async def get_active_signals_detailed(self, instrument: str = None) -> List[Dict[str, Any]]:
        """
        Get detailed active signals (ACTIVE or HIT status) with limits

        Args:
            instrument: Optional filter by instrument

        Returns:
            List of signals with detailed information
        """
        # Build query
        base_query = """
            SELECT 
                s.*,
                COUNT(DISTINCT l.id) as total_limit_count,
                COUNT(DISTINCT CASE WHEN l.status = 'hit' THEN l.id END) as hit_limit_count,
                GROUP_CONCAT(
                    CASE WHEN l.status = 'pending' THEN l.price_level END
                    ORDER BY l.sequence_number
                ) as pending_limits_str,
                GROUP_CONCAT(
                    CASE WHEN l.status = 'hit' THEN l.price_level END
                    ORDER BY l.sequence_number
                ) as hit_limits_str
            FROM signals s
            LEFT JOIN limits l ON s.id = l.signal_id
            WHERE s.status IN (?, ?)
        """

        params = [SignalStatus.ACTIVE.value, SignalStatus.HIT.value]

        if instrument:
            base_query += " AND s.instrument = ?"
            params.append(instrument)

        base_query += " GROUP BY s.id ORDER BY s.created_at DESC"

        signals = await self.db.fetch_all(base_query, tuple(params))

        # Enhance with additional data
        for signal in signals:
            # Parse limit strings into lists
            signal['pending_limits'] = []
            signal['hit_limits'] = []

            if signal.get('pending_limits_str'):
                signal['pending_limits'] = [float(p) for p in signal['pending_limits_str'].split(',')]

            if signal.get('hit_limits_str'):
                signal['hit_limits'] = [float(p) for p in signal['hit_limits_str'].split(',')]

            # Remove temporary string fields
            signal.pop('pending_limits_str', None)
            signal.pop('hit_limits_str', None)

            # Add time remaining for expiry
            if signal.get('expiry_time'):
                expiry = datetime.fromisoformat(signal['expiry_time'])
                now = datetime.now(pytz.UTC)
                if expiry.tzinfo is None:
                    expiry = pytz.UTC.localize(expiry)

                remaining = expiry - now
                if remaining.total_seconds() > 0:
                    hours = int(remaining.total_seconds() // 3600)
                    minutes = int((remaining.total_seconds() % 3600) // 60)
                    signal['time_remaining'] = f"{hours}h {minutes}m"
                else:
                    signal['time_remaining'] = "Expired"
            else:
                signal['time_remaining'] = "No expiry"

            # Add status display info
            signal['status_emoji'] = self._get_status_emoji(signal['status'])
            signal['progress'] = f"{signal['hit_limit_count']}/{signal['total_limit_count']} limits hit"

        return signals

    async def get_signals_for_tracking(self) -> List[Dict[str, Any]]:
        """
        Get all signals that need price tracking (wrapper for DB method)

        Returns:
            List of signals with their pending limits for price tracking
        """
        return await self.db.get_active_signals_for_tracking()

    async def process_limit_hit(self, limit_id: int, actual_price: float = None) -> Dict[str, Any]:
        """
        Process a limit hit event

        Args:
            limit_id: Limit ID that was hit
            actual_price: Actual price at hit (for spread tracking)

        Returns:
            Dict with signal info and status changes
        """
        # Mark limit as hit and get signal info
        result = await self.db.mark_limit_hit(limit_id, actual_price)

        if result['signal_id']:
            # Get updated signal info
            signal = await self.get_signal_with_limits(result['signal_id'])
            result['signal'] = signal

            # Check if all limits are hit
            if signal and len(signal['hit_limits']) == signal['total_limits']:
                result['all_limits_hit'] = True
                logger.info(f"All limits hit for signal {signal['id']}")
            else:
                result['all_limits_hit'] = False

        return result

    async def check_and_update_stop_loss(self, signal_id: int, current_price: float) -> bool:
        """
        Check if stop loss is hit and update status

        Args:
            signal_id: Signal ID
            current_price: Current market price

        Returns:
            True if stop loss was hit
        """
        try:
            signal = await self.db.fetch_one("""
                SELECT direction, stop_loss, status 
                FROM signals 
                WHERE id = ?
            """, (signal_id,))

            if not signal or signal['status'] not in [SignalStatus.HIT.value]:
                return False

            stop_hit = False

            if signal['direction'] == 'long' and current_price <= signal['stop_loss']:
                stop_hit = True
            elif signal['direction'] == 'short' and current_price >= signal['stop_loss']:
                stop_hit = True

            if stop_hit:
                # Directly update to stop_loss status
                success = await self.manually_set_signal_status(
                    signal_id,
                    SignalStatus.STOP_LOSS.value,
                    f'Stop loss hit at {current_price}'
                )

                if success:
                    logger.info(f"Signal {signal_id} hit stop loss at {current_price}")

                return success

            return False

        except Exception as e:
            logger.error(f"Error checking stop loss: {e}", exc_info=True)
            return False

    async def get_statistics(self) -> Dict[str, Any]:
        """
        Get comprehensive database statistics

        Returns:
            Statistics dictionary
        """
        stats = {}

        # Total signals
        total_query = "SELECT COUNT(*) as count FROM signals"
        result = await self.db.fetch_one(total_query)
        stats['total_signals'] = result['count']

        # Signals by status
        status_query = """
            SELECT status, COUNT(*) as count 
            FROM signals 
            GROUP BY status
        """
        status_results = await self.db.fetch_all(status_query)
        stats['by_status'] = {row['status']: row['count'] for row in status_results}

        # Active tracking stats
        tracking_query = """
            SELECT COUNT(*) as count 
            FROM signals 
            WHERE status IN (?, ?)
        """
        result = await self.db.fetch_one(
            tracking_query,
            (SignalStatus.ACTIVE.value, SignalStatus.HIT.value)
        )
        stats['tracking_count'] = result['count']

        # Today's performance
        today_start = datetime.now(pytz.UTC).replace(
            hour=0, minute=0, second=0, microsecond=0
        ).isoformat()

        today_stats = await self.db.get_performance_stats(
            start_date=today_start
        )
        stats['today'] = today_stats['overall']

        # Overall performance
        overall_stats = await self.db.get_performance_stats()
        stats['overall'] = overall_stats['overall']
        stats['by_instrument'] = overall_stats['by_instrument']

        return stats

    async def expire_old_signals(self) -> int:
        """
        Check and expire signals past their expiry time

        Returns:
            Number of signals expired
        """
        now = datetime.now(pytz.UTC).isoformat()

        # Find expired signals
        query = """
            SELECT id FROM signals 
            WHERE status IN (?, ?) 
            AND expiry_time IS NOT NULL 
            AND expiry_time < ?
        """

        expired = await self.db.fetch_all(
            query,
            (SignalStatus.ACTIVE.value, SignalStatus.HIT.value, now)
        )

        count = 0
        for signal in expired:
            success = await self.db.update_signal_status(
                signal['id'],
                SignalStatus.CANCELLED.value,
                'automatic',
                'Expired'
            )
            if success:
                count += 1

                # Cancel pending limits
                await self.db.execute("""
                    UPDATE limits 
                    SET status = 'cancelled' 
                    WHERE signal_id = ? AND status = 'pending'
                """, (signal['id'],))

        if count > 0:
            logger.info(f"Expired {count} signals")

        return count

    def _calculate_expiry(self, expiry_type: str) -> Optional[str]:
        """
        Calculate expiry timestamp based on type

        Args:
            expiry_type: Type of expiry

        Returns:
            ISO format timestamp or None
        """
        if expiry_type == 'no_expiry':
            return None

        # Get current time in EST (typical trading timezone)
        est = pytz.timezone('America/New_York')
        now = datetime.now(est)

        if expiry_type == 'day_end':
            # End of current trading day (5 PM EST)
            expiry = now.replace(hour=17, minute=0, second=0, microsecond=0)
            if now.hour >= 17:
                # If past 5 PM, set to next day
                expiry += timedelta(days=1)

        elif expiry_type == 'week_end':
            # End of trading week (Friday 5 PM EST)
            days_until_friday = (4 - now.weekday()) % 7
            if days_until_friday == 0 and now.hour >= 17:
                days_until_friday = 7
            expiry = now + timedelta(days=days_until_friday)
            expiry = expiry.replace(hour=17, minute=0, second=0, microsecond=0)

        elif expiry_type == 'month_end':
            # Last trading day of month
            next_month = now.month + 1 if now.month < 12 else 1
            year = now.year if now.month < 12 else now.year + 1
            first_of_next = datetime(year, next_month, 1, 17, 0, 0, tzinfo=est)
            # Go back to last weekday
            last_day = first_of_next - timedelta(days=1)
            while last_day.weekday() > 4:  # Saturday = 5, Sunday = 6
                last_day -= timedelta(days=1)
            expiry = last_day

        else:
            # Default to day end
            expiry = now.replace(hour=17, minute=0, second=0, microsecond=0)
            if now.hour >= 17:
                expiry += timedelta(days=1)

        return expiry.isoformat()

    def _get_status_emoji(self, status: str) -> str:
        """Get emoji for status display"""
        emoji_map = {
            SignalStatus.ACTIVE.value: 'üü¢',
            SignalStatus.HIT.value: 'üéØ',
            SignalStatus.PROFIT.value: '‚úÖ',
            SignalStatus.BREAKEVEN.value: '‚ûñ',
            SignalStatus.STOP_LOSS.value: 'üõë',
            SignalStatus.CANCELLED.value: '‚ùå'
        }
        return emoji_map.get(status, '‚ùì')


# Global instance
signal_db = None


def initialize_signal_db(db_manager: DatabaseManager):
    """Initialize the signal database handler"""
    global signal_db
    signal_db = SignalDatabase(db_manager)
    return signal_db